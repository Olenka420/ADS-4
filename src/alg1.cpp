
шаблон < typename T>
класс  TPQueue
{
  // Сюда помещено описание структуры "Очередь с приоритами"
частный:
	T * обр .;          // массив с данными
	размер int ;        // количество элементов в очереди (размер массива)
	Int начала,        // начало очереди
		конец;         // конец очереди
	int count;       // счетчик элементов
общественности:
	TPQueue ( int = 100 );          // конструктор по умолчанию
	~ TPQueue ();                 // деструктор

	void  push ( const T &); // добавить элемент в очередь
	T pop ();              // удалить элемент из очереди
	T get () const ;        // прочитать первый элемент
	bool  isEmpty () const ;      // пустая ли очередь?
	bool  isFull () const ;       // заполнен ли массив?
};
// конструктор по умолчанию
шаблон < typename T>
TPQueue <T> :: TPQueue ( int sizeQueue):
	размер (sizeQueue),
	начало ( 0 ), конец ( 0 ), количество ( 0 )
{
	// дополнительный элемент поможет нам увидеть конец и начало очереди
	arr = новый T [размер + 1 ];
}
// деструктор класса Очередь
шаблон < typename T>
TPQueue <T> :: ~ TPQueue ()
{
	удалить [] обр .;
}
// функция добавления элемента в очередь
шаблон < typename T>
void TPQueue <T> :: push ( const T & item)
{
	// проверяем, ести ли свободное место в очереди
	утверждать (считать <размер);

	if (count == 0 )
	{
		arr [end ++] = item;
		подсчитывать ++;
	}
	еще
	{
		int i = end- 1 ;
		флаг bool = 0 ;
		while (i> = begin && item. prior > arr [i]. prior )
		{
			флаг = 1 ;
			arr [i + 1 ] = arr [i];
			arr [i] = item;
			я--;
		}
		если (флаг == 0 )
			arr [end] = item;
		конец ++;
		подсчитывать ++;
	}

	// проверка кругового заполнения очереди
	если (конец> размер)
		конец - = размер + 1 ; // возвращаемся end на начало очереди
}
// функция удаления элемента из очереди
шаблон < typename T>
T TPQueue <T> :: pop ()
{
	// проверяем, есть ли в очереди элементы
	утверждать (количество> 0 );

	T item = arr [begin ++];
	count--;

	// проверка кругового заполнения очереди
	если (начало> размер)
		начало - = размер + 1 ; // возвращаем начало на начало очереди

	возврат товара;
}
// функция чтения элемента на первой позиции
шаблон < typename T>
T TPQueue <T> :: get () const
{
	// проверяем, есть ли в очереди элементы
	утверждать (количество> 0 );
	возврат arr [начало];
}
// функция проверки очереди на пустоту
шаблон < typename T>
bool TPQueue <T> :: isEmpty () const
{
	счетчик возвратов == 0 ;
}
// функция проверки очереди на заполненность
шаблон < typename T>
bool TPQueue <T> :: isFull () const
{
	счетчик возвратов == размер;
}


структура  SYM
{
	char ch;
	int   prior;
}; 
};
